# Enable Home Assistant API
#api:
#  encryption:
#    key: "UM1ow3iT15L7uBi5/YqCOnlXZPeKyosjBZNl2hzcfsM="

#ota:
#  password: "50be2a475f519ff0d6c932f08a7fd9cf"



# Version info, for full change log:- https://github.com/Uksa007/esphome-jk-bms-can/discussions/2
# V1.13.3 Improve compatibility with Deye and other inverters
# V1.13.2 Send Max Temperature of T1, T2 to inverter
# V1.13.1 Fix compile issues with new version of ESPhome 2023.4.0, set rebulk offset to 2.5
substitutions:
# --------------------------
# name that will appear in esphome and homeassistant.
  name: jk-bms-can
  
# --------------------------
# Number of Battery modules max 8. Each LX U5.4-L battery is 5.4kWh, select the number closest to your capactiy eg 3.2V * 280Ah * 16 = 14.3kWh
  batt_modules: "3"

# --------------------------------------
# Battery Charging setting:
# This is max charging amps eg 50A, for Bulk - Constant Current charging(CC), should be at least 10A less than BMS charge current protection, 0.5C max 
# will be automatically limited to 95% BMS charge current protection
  charge_a: "100"

# the minimum the charge current can be reduced to, if a limit caluclates a lower value charging will be set to 0 (off)
  min_charge_a: "2"

# Absorption Voltage for Constant Voltage charging(CV). This is Absorption voltage you want the inverter to charge with 3.45v per cell. Value will be multiplied by cells reported from the BMS. 
  cell_absorption_v: "3.45"

  cell_absorption_v_slider_min: "3.3" # min value for GUI slider, recommended LiFePo4 = 3.3, LiIon = 3.8
  cell_absorption_v_slider_max: "3.6" # max value for GUI slider, recommended LiFePo4 = 3.6, LiIon = 4.2

# Absorption time in minutes to hold charge voltage after charge voltage is reached eg 10
# timer will be reset if balance voltage is not reached yet when balance voltage is set higher than absorption voltage
# and will also be reset when balancing is active
  absorption_time: "10"

# Rebulk offset, x Volts below absorption volatge battery will request rebulk, eg 55.2-3 = 52.5v, roughly 90% SOC.
  cell_rebulk_v: "3.35"

  cell_rebulk_v_slider_min: "3.2" # min value for GUI slider, recommended LiFePo4 = 3.2, LiIon = 4.0
  cell_rebulk_v_slider_max: "3.5" # max value for GUI slider, recommended LiFePo4 = 3.5, LiIon = 4.18

# --------------------------------------
# Battery Discharge setting:
# Max discharge amps eg 100, should be at least 10A less than BMS over dischange current protection, 0.5C max
# will be reset if higher than 95% of overdischarge current protection of the BMS
  discharge_a: "100"

# the minimum the discharge current can be reduced to, if a limit caluclates a lower value discharging will be set to 0 (off)
  min_discharge_a: "2"

# Minimum discharge voltage eg 48v/16 = 3V per cell
  cell_min_dischange_v: "3.0"

  cell_min_dischange_v_slider_min: "2.5" # min value for GUI slider, recommended LiFePo4 = 2.5, LiIon = 2.5
  cell_min_dischange_v_slider_max: "3.2" # min value for GUI slider, recommended LiFePo4 = 3.2, LiIon = 3.5
# --------------------------------------
# Battery State of Health (SOH) setting:
# Maximum charging cycles is used to calculate the battey SOH, LF280K=6000.0 LF280=3000.0 (decimal is required)
  max_cycles: "6000.0"
# --------------------------------------
# ESP32 CAN/Serail port pins:
# GPIO pins your CAN bus transceiver(TJA1050) is connected to the ESP, note! TX->TX and RX->RX. 
  can_tx_pin: GPIO3
  can_rx_pin: GPIO5
# GPIO pins your JK-BMS RS485(TTL) is connected to the ESP TX->RX and RX->TX. 
  tx_pin: GPIO7
  rx_pin: GPIO9
# --------------------------------------
#### Don't make changes below this ####
  external_components_source: github://Ackmaniac/esphome-jk-bms-can@develop # TODO set to main

esphome:
  name: ${name}
  includes:
    - jk-bms-helper.h
  on_boot:
    then:
      - switch.turn_on: inverter_charging
      - switch.turn_on: inverter_discharging
  platformio_options:
    upload_speed: 115200
    board_build.extra_flags:
      - "-DARDUINO_USB_CDC_ON_BOOT=0"

esp32:
#  board: esp32doit-devkit-v1

  board: lolin_s2_mini
  variant: ESP32S2

  framework:
    type: arduino
    version: recommended
    
#    type: esp-idf
#    version: recommended
#    sdkconfig_options:
#      CONFIG_ESP_CONSOLE_USB_CDC: y
    

external_components:
  - source: ${external_components_source}
    refresh: 0s

globals:
  - id: can_305_rx
    type: int
    restore_value: no
    initial_value: '0'
  - id: no_uart_update_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: uart_missing_error
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: charge_status
    type: std::string
    restore_value: no
    initial_value: '"Startup"'

button:
  - platform: restart
    name: "Restart button"
    id: restart_button
    internal: true

wifi:
  #reboot_timeout: 180min
  #ssid: !secret wifi_ssid
  #password: !secret wifi_password
  #domain: !secret domain

  ap:
#    ssid: "Jk-Bms Fallback Hotspot"
    password: "B3ytP03VQjeh"

web_server:
  port: 80
  local: true
  auth:
    username: "jkbms" # !secret jk_bms_web_server_username
    password: "jkbms" # !secret jk_bms_web_server_password

#ota:

logger:
  baud_rate: 115200
  hardware_uart: UART0 # USB_CDC

# Please use the native `api` component instead of the `mqtt` section
# if you use Home Assistant. The native API is more lightweight.
#api:

#mqtt:
#  broker: !secret mqtt_host
#  username: !secret mqtt_username
#  password: !secret mqtt_password
#  id: mqtt_client

output:
  - platform: gpio
    pin: 2
    id: led
    inverted: true

light:
  - platform: binary
    output: led
    id: led_buitin
    name: "Builtin LED"
    internal: true

uart:
  id: uart_0
  baud_rate: 115200
  rx_buffer_size: 384
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}

jk_modbus:
  id: modbus0
  uart_id: uart_0

jk_bms:
  id: bms0
  jk_modbus_id: modbus0
  enable_fake_traffic: true # TODO disable

canbus:
  - platform: esp32_can
    tx_pin: ${can_tx_pin}
    rx_pin: ${can_rx_pin}
    can_id: 4
    bit_rate: 500kbps
    on_frame:
    - can_id: 0x305 # SMA/LG/Pylon/Goodwe reply
      then:
        - light.toggle:
            id: led_buitin
        - lambda: |-
            // ESP_LOGI("main", "received can id: 0x305 ACK");
            id(can_305_rx) = 0;

interval:
  - interval: 10ms
    then:
      if:
        condition:
          lambda: |-
            if (id(bms0).get_states_updated()) {
              id(uart_missing_error) = false;
              id(no_uart_update_counter) = 0;
              return true;
            } else if (id(no_uart_update_counter) ++ >= 500) { // 500 is 500x10ms = 5000ms = 5s
              id(uart_missing_error) = true;
              return true;
            }
            return false;
        then:
          - lambda: |-
              id(bms0).set_states_updated(false);
          
          - canbus.send: # Warning, Alarms
              can_id: 0x359
              data: !lambda |-
                uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                uint16_t jk_errormask = id(errors_bitmask).state;
                int batt_mods = ${batt_modules};
                // Alarms
                if ((jk_errormask & 0x04) | (jk_errormask & 0x80) | (jk_errormask & 0x400)) { // Hight.Voltage.Alarm JK bit 2,7,10 
                  can_mesg[0] = 0x02; // bit 1
                }
                if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) { // Low.Voltage.Alarm JK bit 3,11 
                  can_mesg[0] = can_mesg[0] | 0x04; // bit 2
                }
                if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) { // Hight.Temp.Alarm JK bit 1,4,8
                  can_mesg[0] = can_mesg[0] | 0x08; // bit 3
                }
                if (jk_errormask & 0x200) { // Low.Temp.Alarm JK bit 9
                  can_mesg[0] = can_mesg[0] | 0x10; // bit 4
                }
                if (jk_errormask & 0x40) { // Discharge.Over.Current JK bit 6
                  can_mesg[0] = can_mesg[0] | 0x80; // bit 7
                }
                if (jk_errormask & 0x20) { // Charge.Over.Current JK bit 5
                  can_mesg[1] = 0x01; // bit 0
                }
                if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) { // BMS Internal JK bit 12,13
                  can_mesg[1] = can_mesg[1] | 0x08; // bit 3
                }
                if (jk_errormask & 0x80) { // Cell Imbalance JK bit 7
                  can_mesg[1] = can_mesg[1] | 0x10; // bit 4 
                }
                /// Warnings
                can_mesg[2] = 0x00;
                can_mesg[3] = 0x00;
                /// Flags
                can_mesg[4] = batt_mods; // Module in parallel
                can_mesg[5] = 0x00;
                can_mesg[6] = 0x00;
                can_mesg[7] = 0x00; // DIP switches 1,3 10000100 0x84
                ESP_LOGI("main", "send can id: 0x359 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
          - delay: 10ms

          - canbus.send: # BMS instructs inverter: Charge Volts, Charge Amps, Discharge Amps, Min voltage
              can_id: 0x351
              data: !lambda |-
                uint8_t can_mesg[7];
                if (  !id(charging_switch).state
                    | !id(inverter_charging).state)
                {
                  id(charge_status) = "Disabled";

                } else if (id(inverter_chg_on).state) {
                  id(charge_status) = "Bulk Manually";

                } else if (  id(charging_switch).state
                           & id(inverter_charging).state
                           & id(charge_status) == "Disabled")
                {
                  id(charge_status) = "Wait";

                } else if (  !id(inverter_chg_on).state
                           & id(charge_status) == "Bulk Manually")
                {
                  id(charge_status) = "Wait";

                } else if (id(total_voltage).state <= (id(cell_idle_voltage).state * id(cells).state)) { // Bulk Charge eg 53.6v 10% 
                  if (id(absorption_script).is_running()) id(absorption_script).stop();
                  id(charge_status) = "Bulk";

                } else if (  id(total_voltage).state > id(cell_idle_voltage).state * id(cells).state
                           & id(total_voltage).state < (id(cell_absorption_voltage).state * id(cells).state) - 0.05) // If in startup rebulk
                {
                  if (id(charge_status) == "Startup") {
                    id(charge_status) = "Bulk"; // If in startup, 10% low rebulk
                  }

                } else if (id(total_voltage).state >= (id(cell_absorption_voltage).state * id(cells).state)  - 0.05) { // 10 % from top start absorption timer
                  if (id(charge_status) == "Bulk") {
                    id(charge_status) = "Absorption";
                    if (!id(absorption_script).is_running()) id(absorption_script).execute();
                  }

                } else if (  id(charge_status) == "Absorption"                                        // when in absorption
                           & id(cell_absorption_voltage).state > id(balance_starting_voltage).state   // and absorption voltage is set higher than balance_starting_voltage
                           & (  id(max_cell_voltage).state < id(balance_starting_voltage).state       // and (   max cell is still below balance_starting_voltage
                              | id(balancing).state)) // reset script timer if balancing is active    //      or balancing is active)
                { 
                  if (id(absorption_script).is_running()) id(absorption_script).stop();             // then reset absorption script
                  id(absorption_script).execute();
                } else {
                  id(charge_status) = "Wait";
                }
                
                // # set esphome "charging_current" to match with max bms "charging_overcurrent_protection"
                if (id(charging_current).state > id(charging_overcurrent_protection).state * 0.95f) {
                  id(charging_current).publish_state(id(charging_overcurrent_protection).state * 0.95f);
                }

                // # set esphome "discharging_current" to match with max bms "discharging_overcurrent_protection"
                if (id(discharging_current).state > id(discharging_overcurrent_protection).state * 0.95f) {
                  id(discharging_current).publish_state(id(discharging_overcurrent_protection).state * 0.95f);
                }

                // # startCalculuation
                initValues(min(id(charging_overcurrent_protection).state * 0.95f, id(charging_current).state),
                           min(id(discharging_overcurrent_protection).state * 0.95f, id(discharging_current).state),
                           ${min_charge_a},
                           ${min_discharge_a});

                // # cell_voltage_overvoltage
                limitChargeCurrent(id(max_cell_voltage).state,
                                  id(cell_voltage_overvoltage_recovery).state,
                                  id(cell_voltage_overvoltage_protection).state,
                                  0.1f,
                                  "cell_voltage_overvoltage");

                // # cell_voltage_undervoltage
                limitChargeCurrent(id(min_cell_voltage).state,
                                  id(cell_voltage_undervoltage_recovery).state,
                                  id(cell_voltage_undervoltage_protection).state,
                                  0.1f,
                                  "cell_voltage_undervoltage");

                // # power_tube_temperature
                limitChargeAndDischargeCurrent(id(power_tube_temperature).state,
                                              id(power_tube_temperature_recovery).state,
                                              id(power_tube_temperature_protection).state,
                                              0.1f,
                                              "power_tube_temperature",
                                              true);

                float maxBatteryTemperature = max(id(temperature_sensor_1).state, id(temperature_sensor_2).state);

                // # battery_temperature_sensor_temperature
                limitChargeAndDischargeCurrent(maxBatteryTemperature,
                                              id(temperature_sensor_temperature_recovery).state,
                                              id(temperature_sensor_temperature_protection).state,
                                              0.1f,
                                              "battery_temperature_sensor_temperature",
                                              true);

                // # battery_charging_high_temperature
                limitChargeCurrent(maxBatteryTemperature,
                                  id(charging_high_temperature_protection).state - 10.0,
                                  id(charging_high_temperature_protection).state,
                                  0.1f,
                                  "battery_charging_high_temperature",
                                  true);

                // # battery_discharging_high_temperature
                limitDischargeCurrent(maxBatteryTemperature,
                                      id(discharging_high_temperature_protection).state - 10.0,
                                      id(discharging_high_temperature_protection).state,
                                      0.1f,
                                      "battery_discharging_high_temperature",
                                      true);

                float minBatteryTemperature = min(id(temperature_sensor_1).state, id(temperature_sensor_2).state);

                // # battery_charging_low_temperature
                limitChargeCurrent(minBatteryTemperature,
                                  id(charging_low_temperature_recovery).state,
                                  id(charging_low_temperature_protection).state,
                                  0.1f,
                                  "battery_charging_low_temperature");

                // # battery_discharging_low_temperature
                limitDischargeCurrent(minBatteryTemperature,
                                      id(discharging_low_temperature_recovery).state,
                                      id(discharging_low_temperature_protection).state,
                                      0.1f,
                                      "battery_discharging_low_temperature");

                setRampups(1.0f);

                if (id(uart_missing_error)) {
                  id(charge_status) = "Disabled";
                  can_mesg[0] = uint16_t(40 * 10) & 0xff;
                  can_mesg[1] = uint16_t(40 * 10) >> 8 & 0xff;
                  can_mesg[2] = 0;
                  can_mesg[3] = 0;
                  can_mesg[4] = 0x00;
                  can_mesg[5] = 0x00;
                  can_mesg[6] = uint16_t(10 * 10) & 0xff;
                  can_mesg[7] = uint16_t(10 * 10) >> 8 & 0xff;
                  
                  if (id(limited_charge_current_reason).state != "") id(limited_charge_current_reason).publish_state("");
                  if (id(limited_discharge_current_reason).state != "") id(limited_discharge_current_reason).publish_state("");
                } else {
                  if ((!id(charging_switch).state) | (!id(inverter_charging).state)) { // Overides to disable charging
                    can_mesg[0] = uint16_t(id(cell_idle_voltage).state * id(cells).state * 10) & 0xff;
                    can_mesg[1] = uint16_t(id(cell_idle_voltage).state * id(cells).state * 10) >> 8 & 0xff;
                    can_mesg[2] = 0;
                    can_mesg[3] = 0;
                    if (id(limited_charge_current_reason).state != "") id(limited_charge_current_reason).publish_state("");
                  } else if ((id(charge_status) == "Bulk") | (id(charge_status) == "Absorption") | (id(inverter_chg_on).state)) {
                    can_mesg[0] = uint16_t(id(cell_absorption_voltage).state * id(cells).state * 10) & 0xff;
                    can_mesg[1] = uint16_t(id(cell_absorption_voltage).state * id(cells).state * 10) >> 8 & 0xff;
                    can_mesg[2] = uint16_t(limitedChargeCurrent * 10) & 0xff;
                    can_mesg[3] = uint16_t(limitedChargeCurrent * 10) >> 8 & 0xff;
                    if (id(limited_charge_current_reason).state != limitedChargeCurrentReason) id(limited_charge_current_reason).publish_state(limitedChargeCurrentReason);
                  } else {
                    can_mesg[0] = uint16_t(id(cell_idle_voltage).state * id(cells).state * 10) & 0xff;
                    can_mesg[1] = uint16_t(id(cell_idle_voltage).state * id(cells).state * 10) >> 8 & 0xff;
                    can_mesg[2] = 0;
                    can_mesg[3] = 0;
                    if (id(limited_charge_current_reason).state != "") id(limited_charge_current_reason).publish_state("");
                  }
                  
                  if ((id(discharging_switch).state) & (id(inverter_discharging).state)) {
                    can_mesg[4] = uint16_t(limitedDischargeCurrent * 10) & 0xff;
                    can_mesg[5] = uint16_t(limitedDischargeCurrent * 10) >> 8 & 0xff;
                    if (id(limited_discharge_current_reason).state != limitedDischargeCurrentReason) id(limited_discharge_current_reason).publish_state(limitedDischargeCurrentReason);
                  } else {
                    can_mesg[4] = 0x00;
                    can_mesg[5] = 0x00;
                    if (id(limited_discharge_current_reason).state != "") id(limited_discharge_current_reason).publish_state("");
                  }
                  can_mesg[6] = uint16_t(id(cell_min_dischange_voltage).state * id(cells).state * 10) & 0xff;
                  can_mesg[7] = uint16_t(id(cell_min_dischange_voltage).state * id(cells).state * 10) >> 8 & 0xff;
                }

                id(charging_status).publish_state(id(charge_status));

                ESP_LOGI("main", "min_dischange_voltage %.1f", int16_t(id(cell_min_dischange_voltage).state * id(cells).state * 10) / 10.0f);

                ESP_LOGI("main", "send can id: 0x351 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                ESP_LOGI("main", "send can id: Charge Status %s", id(charge_status).c_str());
                return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
          - delay: 10ms

          - canbus.send: # Actual SOC, SOH
              can_id: 0x355
              data: !lambda |-
                int soh = round(((id(charging_cycles).state/${max_cycles})-1)*-100);
                uint8_t can_mesg[3];
                can_mesg[0] = uint16_t(id(capacity_remaining).state) & 0xff;
                can_mesg[1] = uint16_t(id(capacity_remaining).state) >> 8 & 0xff;
                can_mesg[2] = soh & 0xff;
                can_mesg[3] = soh >> 8 & 0xff;
                ESP_LOGI("main", "send can id: 0x355 hex: %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3]);
                return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3]};
          - delay: 10ms

          - canbus.send: # Actual Volts, Amps, Temp
              can_id: 0x356
              data: !lambda |-
                uint8_t can_mesg[5];
                can_mesg[0] = uint16_t(id(total_voltage).state * 100) & 0xff;
                can_mesg[1] = uint16_t(id(total_voltage).state * 100) >> 8 & 0xff;
                can_mesg[2] = int16_t(id(current).state * 10) & 0xff;
                can_mesg[3] = int16_t(id(current).state * 10) >> 8 & 0xff;
                can_mesg[4] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                can_mesg[5] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                ESP_LOGI("main", "send can id: 0x356 hex: %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5]);
                return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5]};
          - delay: 10ms

          - canbus.send: # Request flag to Enable/Disable: Charge, Discharge
              can_id: 0x35C
              data: !lambda |-
                uint8_t can_mesg[1];

                if (id(uart_missing_error)) {
                  can_mesg[0] = 0x00;
                  can_mesg[1] = 0x00;
                } else {
                  if ((id(charging_switch).state) & (id(inverter_charging).state)) {
                    can_mesg[0] = 0x80;
                  } else {
                    can_mesg[0] = 0x00;
                  }
                  if ((id(discharging_switch).state) & (id(inverter_discharging).state)) {
                    can_mesg[0] = can_mesg[0] | 0x40;
                  }
                  can_mesg[1] = 0x00;
                }
                ESP_LOGI("main", "send can id: 0x35C hex: %x %x", can_mesg[0], can_mesg[1]);
                return {can_mesg[0], can_mesg[1]};
          - delay: 10ms

          - canbus.send: # Actual Max Cell Temp, Min Cell Temp, Max Cell V, Min Cell V
              can_id: 0x70
              data: !lambda |-
                int max_cell_voltage_i = id(max_cell_voltage).state * 100.0;
                int min_cell_voltage_i = id(min_cell_voltage).state * 100.0;
                uint8_t can_mesg[7];
                can_mesg[0] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                can_mesg[1] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                can_mesg[2] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                can_mesg[3] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                can_mesg[4] = max_cell_voltage_i & 0xff;
                can_mesg[5] = max_cell_voltage_i >> 8 & 0xff;
                can_mesg[6] = min_cell_voltage_i & 0xff;
                can_mesg[7] = min_cell_voltage_i >> 8 & 0xff;
                ESP_LOGI("main", "send can id: 0x70 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
          - delay: 10ms

          - canbus.send: # Actual Max Cell Temp ID, Min Cell Temp ID, Max Cell V ID, Min Cell ID
              can_id: 0x371
              data: !lambda |-
                uint8_t can_mesg[7];
                can_mesg[0] = 0x01;
                can_mesg[1] = 0x00;
                can_mesg[2] = 0x02;
                can_mesg[3] = 0x00;
                can_mesg[4] = uint16_t(id(max_voltage_cell).state) & 0xff;
                can_mesg[5] = uint16_t(id(max_voltage_cell).state) >> 8 & 0xff;
                can_mesg[6] = uint16_t(id(min_voltage_cell).state) & 0xff;
                can_mesg[7] = uint16_t(id(min_voltage_cell).state) >> 8 & 0xff;
                ESP_LOGI("main", "send can id: 0x371 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
          - delay: 10ms

          - canbus.send: # GOODWE
              can_id: 0x35E
              data: [0x47, 0x4F, 0x4F, 0x44, 0x57, 0x45, 0x20, 0x20]

          - lambda: |- # Detect no CAN reply
              if (id(can_305_rx) > 30) {
                ESP_LOGI("main", "No rx can 0x305 reply, Inverter not connected/responding, Rebooting...");
                //id(restart_button).press(); # TODO uncomment
                id(can_305_rx) = 0;
              } else {
                id(can_305_rx) ++;
              }

binary_sensor:
  - platform: jk_bms
    balancing:
      id: balancing
      name: "balancing"
    balancing_switch:
      name: "balancing switch"
    charging:
      name: "charging"
    charging_switch:
      id: charging_switch
      name: "charging switch"
    discharging:
      name: "discharging"
    discharging_switch:
      id: discharging_switch
      name: "discharging switch"
    dedicated_charger_switch:
      name: "dedicated charger switch"

sensor:
  - platform: jk_bms
    min_cell_voltage:
      id: min_cell_voltage
      name: "min cell voltage"
    max_cell_voltage:
      id: max_cell_voltage
      name: "max cell voltage"
    min_voltage_cell:
      id: min_voltage_cell
      name: "min voltage cell"
    max_voltage_cell:
      id: max_voltage_cell
      name: "max voltage cell"
    delta_cell_voltage:
      name: "delta cell voltage"
    average_cell_voltage:
      name: "average cell voltage"
    cells:
      id: cells
      name: "cells"
    cell_voltage_1:
      name: "cell voltage  1"
    cell_voltage_2:
      name: "cell voltage  2"
    cell_voltage_3:
      name: "cell voltage  3"
    cell_voltage_4:
      name: "cell voltage  4"
    cell_voltage_5:
      name: "cell voltage  5"
    cell_voltage_6:
      name: "cell voltage  6"
    cell_voltage_7:
      name: "cell voltage  7"
    cell_voltage_8:
      name: "cell voltage  8"
    cell_voltage_9:
      name: "cell voltage  9"
    cell_voltage_10:
      name: "cell voltage 10"
    cell_voltage_11:
      name: "cell voltage 11"
    cell_voltage_12:
      name: "cell voltage 12"
    cell_voltage_13:
      name: "cell voltage 13"
    cell_voltage_14:
      name: "cell voltage 14"
    cell_voltage_15:
      name: "cell voltage 15"
    cell_voltage_16:
      name: "cell voltage 16"
#    cell_voltage_17:
#      name: "cell voltage 17"
#    cell_voltage_18:
#      name: "cell voltage 18"
#    cell_voltage_19:
#      name: "cell voltage 19"
#    cell_voltage_20:
#      name: "cell voltage 20"
#    cell_voltage_21:
#      name: "cell voltage 21"
#    cell_voltage_22:
#      name: "cell voltage 22"
#    cell_voltage_23:
#      name: "cell voltage 23"
#    cell_voltage_24:
#      name: "cell voltage 24"
    power_tube_temperature:
      id: power_tube_temperature
      name: "power tube temperature"
    temperature_sensor_1:
      id: temperature_sensor_1
      name: "temperature sensor 1"
    temperature_sensor_2:
      id: temperature_sensor_2
      name: "temperature sensor 2"
    total_voltage:
      id: total_voltage
      name: "total voltage"
    current:
      id: current
      name: "current"
    power:
      name: "power"
    charging_power:
      name: "charging power"
    discharging_power:
      name: "discharging power"
    capacity_remaining:
      id: capacity_remaining
      name: "capacity remaining"
    capacity_remaining_derived:
      name: "capacity remaining derived"
    temperature_sensors:
      name: "temperature sensors"
    charging_cycles:
      name: "charging cycles"
      id: charging_cycles
    total_charging_cycle_capacity:
      name: "total charging cycle capacity"
    battery_strings:
      name: "battery strings"
    errors_bitmask:
      id: errors_bitmask
      name: "errors bitmask"
    operation_mode_bitmask:
      name: "operation mode bitmask"
    total_voltage_overvoltage_protection:
      id: total_voltage_overvoltage_protection
      name: "total voltage overvoltage protection"
    total_voltage_undervoltage_protection:
      id: total_voltage_undervoltage_protection
      name: "total voltage undervoltage protection"
    cell_voltage_overvoltage_protection:
      id: cell_voltage_overvoltage_protection
      name: "cell voltage overvoltage protection"
    cell_voltage_overvoltage_recovery:
      id: cell_voltage_overvoltage_recovery
      name: "cell voltage overvoltage recovery"
    cell_voltage_overvoltage_delay:
      name: "cell voltage overvoltage delay"
    cell_voltage_undervoltage_protection:
      id: cell_voltage_undervoltage_protection
      name: "cell voltage undervoltage protection"
    cell_voltage_undervoltage_recovery:
      id: cell_voltage_undervoltage_recovery
      name: "cell voltage undervoltage recovery"
    cell_voltage_undervoltage_delay:
      name: "cell voltage undervoltage delay"
    cell_pressure_difference_protection:
      name: "cell pressure difference protection"
    discharging_overcurrent_protection:
      id: discharging_overcurrent_protection
      name: "discharging overcurrent protection"
    discharging_overcurrent_delay:
      name: "discharging overcurrent delay"
    charging_overcurrent_protection:
      id: charging_overcurrent_protection
      name: "charging overcurrent protection"
    charging_overcurrent_delay:
      name: "charging overcurrent delay"
    balance_starting_voltage:
      id: balance_starting_voltage
      name: "balance starting voltage"
    balance_opening_pressure_difference:
      name: "balance opening pressure difference"
    power_tube_temperature_protection:
      id: power_tube_temperature_protection
      name: "power tube temperature protection"
    power_tube_temperature_recovery:
      id: power_tube_temperature_recovery
      name: "power tube temperature recovery"
    temperature_sensor_temperature_protection:
      id: temperature_sensor_temperature_protection
      name: "temperature sensor temperature protection"
    temperature_sensor_temperature_recovery:
      id: temperature_sensor_temperature_recovery
      name: "temperature sensor temperature recovery"
    temperature_sensor_temperature_difference_protection:
      name: "temperature sensor temperature difference protection"
    charging_high_temperature_protection:
      id: charging_high_temperature_protection
      name: "charging high temperature protection"
    discharging_high_temperature_protection:
      id: discharging_high_temperature_protection
      name: "discharging high temperature protection"
    charging_low_temperature_protection:
      id: charging_low_temperature_protection
      name: "charging low temperature protection"
    charging_low_temperature_recovery:
      id: charging_low_temperature_recovery
      name: "charging low temperature recovery"
    discharging_low_temperature_protection:
      id: discharging_low_temperature_protection
      name: "discharging low temperature protection"
    discharging_low_temperature_recovery:
      id: discharging_low_temperature_recovery
      name: "discharging low temperature recovery"
    total_battery_capacity_setting:
      name: "total battery capacity setting"
    current_calibration:
      name: "current calibration"
    device_address:
      name: "device address"
    sleep_wait_time:
      name: "sleep wait time"
    alarm_low_volume:
      name: "alarm low volume"
    manufacturing_date:
      name: "manufacturing date"
    total_runtime:
      name: "total runtime"
#    start_current_calibration:
#      name: "start current calibration"
    actual_battery_capacity:
      name: "actual battery capacity"
#    protocol_version:
#      name: "protocol version"
# Uptime sensor
  - platform: uptime
    name: Uptime Sensor
    id: uptime_sensor
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();
text_sensor:
  - platform: jk_bms
    errors:
      name: "errors"
    operation_mode:
      name: "operation mode"
    battery_type:
      name: "battery type"
    password:
      name: "password"
    device_type:
      name: "device type"
    software_version:
      name: "software version"
    manufacturer:
      name: "manufacturer"
    total_runtime_formatted:
      name: "total runtime formatted"
# Template text sensors
  - platform: template
    name: Uptime Human Readable
    id: uptime_human
    icon: mdi:clock-start
  - platform: template
    name: "Charging Status"
    id: charging_status
  - platform: template
    name: "Limited Charge Current Reason"
    id: limited_charge_current_reason
  - platform: template
    name: "Limited Discharge Current Reason"
    id: limited_discharge_current_reason


# Slider
number:
  - platform: template
    name: "Cell absorption voltage"
    id: "cell_absorption_voltage"
    step: 0.01
    min_value: "${cell_absorption_v_slider_min}"
    max_value: "${cell_absorption_v_slider_max}"
    mode: slider
    initial_value: "${cell_absorption_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    restore_value: true
  - platform: template
    name: "Cell idle voltage"
    id: "cell_idle_voltage"
    step: 0.01
    min_value: "${cell_rebulk_v_slider_min}"
    max_value: "${cell_rebulk_v_slider_max}"
    mode: slider
    initial_value: "${cell_rebulk_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    restore_value: true
  - platform: template
    name: "Cell min discharge voltage"
    id: "cell_min_dischange_voltage"
    step: 0.01
    min_value: "${cell_min_dischange_v_slider_min}"
    max_value: "${cell_min_dischange_v_slider_max}"
    mode: slider
    initial_value: "${cell_min_dischange_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    restore_value: true
  - platform: template
    name: "Charging current max"
    id: "charging_current"
    step: 1
    min_value: "${min_charge_a}"
    max_value: 200
    mode: slider
    initial_value: "${charge_a}"
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
    restore_value: true
  - platform: template
    name: "Discharging current max"
    id: "discharging_current"
    step: 1
    min_value: "${min_discharge_a}"
    max_value: 200
    mode: slider
    initial_value: "${discharge_a}"
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
    restore_value: true

script:
  - id: absorption_script
    then:
      - lambda: id(charge_status) = "Absorption";
      - delay: ${absorption_time}min
      - lambda: id(charge_status) = "Wait";

switch:
  - platform: template
    name: Charging enabled
    id: inverter_charging
    optimistic: true
    restore_state: true
  - platform: template
    name: Discharge enabled
    id: inverter_discharging
    optimistic: true
    restore_state: true
  - platform: template
    name: Charging manually (top bal)
    id: inverter_chg_on
    optimistic: true
    restore_state: true